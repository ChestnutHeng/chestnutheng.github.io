<!DOCTYPE html>
<html lang="zh-CN">
    <head>
	<meta name="generator" content="Hugo 0.118.2">
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <title>子恒的博客</title><meta name="Description" content="技术|思考"><meta property="og:title" content="子恒的博客" />
<meta property="og:description" content="技术|思考" />
<meta property="og:type" content="website" />
<meta property="og:url" content="http://chestnutheng.github.io/" /><meta property="og:image" content="http://chestnutheng.github.io/logo.png"/><meta property="og:site_name" content="子恒的博客" />
<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="http://chestnutheng.github.io/logo.png"/>

<meta name="twitter:title" content="子恒的博客"/>
<meta name="twitter:description" content="技术|思考"/>
<meta name="application-name" content="我的网站">
<meta name="apple-mobile-web-app-title" content="我的网站"><meta name="theme-color" content="#ffffff"><meta name="msapplication-TileColor" content="#da532c"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="http://chestnutheng.github.io/" /><link rel="alternate" href="/index.xml" type="application/rss+xml" title="子恒的博客">
    <link rel="feed" href="/index.xml" type="application/rss+xml" title="子恒的博客"><link rel="stylesheet" href="/css/style.min.css"><link rel="preload" href="/lib/fontawesome-free/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
        <noscript><link rel="stylesheet" href="/lib/fontawesome-free/all.min.css"></noscript><link rel="preload" href="/lib/animate/animate.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
        <noscript><link rel="stylesheet" href="/lib/animate/animate.min.css"></noscript><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "WebSite",
        "url": "http:\/\/chestnutheng.github.io\/","inLanguage": "zh-CN","author": {
                "@type": "Person",
                "name": "子恒"
            },"description": "技术|思考","name": "子恒的博客"
    }
    </script></head>
    <body data-header-desktop="fixed" data-header-mobile="auto"><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('auto' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'auto' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="子恒的博客">子恒的博客</a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item active" href="/"> 主页 </a><a class="menu-item" href="/posts/"> 文章 </a><a class="menu-item" href="/tags/"> 标签 </a><a class="menu-item" href="/categories/"> 分类 </a><a class="menu-item" href="/freinds/"> 友链 </a><a class="menu-item" href="/about/"> 关于 </a><span class="menu-item delimiter"></span><span class="menu-item search" id="search-desktop">
                        <input type="text" placeholder="Search titles or contents..." id="search-input-desktop">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-desktop" title="Search">
                            <i class="fas fa-search fa-fw" aria-hidden="true"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-desktop" title="Clear">
                            <i class="fas fa-times-circle fa-fw" aria-hidden="true"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-desktop">
                            <i class="fas fa-spinner fa-fw fa-spin" aria-hidden="true"></i>
                        </span>
                    </span><a href="javascript:void(0);" class="menu-item theme-switch" title="Switch Theme">
                    <i class="fas fa-adjust fa-fw" aria-hidden="true"></i>
                </a></div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="子恒的博客">子恒的博客</a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><div class="search-wrapper">
                    <div class="search mobile" id="search-mobile">
                        <input type="text" placeholder="Search titles or contents..." id="search-input-mobile">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-mobile" title="Search">
                            <i class="fas fa-search fa-fw" aria-hidden="true"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-mobile" title="Clear">
                            <i class="fas fa-times-circle fa-fw" aria-hidden="true"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-mobile">
                            <i class="fas fa-spinner fa-fw fa-spin" aria-hidden="true"></i>
                        </span>
                    </div>
                    <a href="javascript:void(0);" class="search-cancel" id="search-cancel-mobile">
                        Cancel
                    </a>
                </div><a class="menu-item" href="/" title="">主页</a><a class="menu-item" href="/posts/" title="">文章</a><a class="menu-item" href="/tags/" title="">标签</a><a class="menu-item" href="/categories/" title="">分类</a><a class="menu-item" href="/freinds/" title="">友链</a><a class="menu-item" href="/about/" title="">关于</a><a href="javascript:void(0);" class="menu-item theme-switch" title="Switch Theme">
                <i class="fas fa-adjust fa-fw" aria-hidden="true"></i>
            </a></div>
    </div>
</header><div class="search-dropdown desktop">
        <div id="search-dropdown-desktop"></div>
    </div>
    <div class="search-dropdown mobile">
        <div id="search-dropdown-mobile"></div>
    </div><main class="main">
                <div class="container"><div class="page home" data-home="posts"><div class="home-profile"><div class="home-avatar"><a href="/" title="主页"><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="/favicon.ico"
        data-srcset="/favicon.ico, /favicon.ico 1.5x, /favicon.ico 2x"
        data-sizes="auto"
        alt="/favicon.ico"
        title="/favicon.ico" /></a></div><h1 class="home-title">子恒的博客</h1><div class="home-subtitle"><div id="id-1" class="typeit"></div></div><div class="links"><a href="https://github.com/chestnutheng" title="GitHub" target="_blank" rel="noopener noreffer me"><i class="fab fa-github fa-fw" aria-hidden="true"></i></a><a href="https://weibo.com/2461859532" title="微博" target="_blank" rel="noopener noreffer me"><i class="fab fa-weibo fa-fw" aria-hidden="true"></i></a><a href="https://www.zhihu.com/people/lu-zi-heng-91" title="知乎" target="_blank" rel="noopener noreffer me"><i data-svg-src="/lib/simple-icons/icons/zhihu.min.svg" aria-hidden="true"></i></a><a href="https://www.douban.com/people/117010233" title="豆瓣" target="_blank" rel="noopener noreffer me"><i data-svg-src="/lib/simple-icons/icons/douban.min.svg" aria-hidden="true"></i></a><a href="https://space.bilibili.com/710169" title="bilibili" target="_blank" rel="noopener noreffer me"><i data-svg-src="/lib/simple-icons/icons/bilibili.min.svg" aria-hidden="true"></i></a><a href="mailto:chestnutheng@hotmail.com" title="Email" rel="me"><i class="far fa-envelope fa-fw" aria-hidden="true"></i></a><a href="/index.xml" title="RSS" target="_blank" rel="noopener noreffer me"><i class="fas fa-rss fa-fw" aria-hidden="true"></i></a></div></div>
<article class="single summary" itemscope itemtype="http://schema.org/Article"><h1 class="single-title" itemprop="name headline">
        <a href="/c1w1-c1w2/">[深度学习]C1W1~C1W2</a>
    </h1><div class="post-meta"><span class="post-author"><a href="about" title="Author" rel="author" class="author"><i class="fas fa-user-circle fa-fw" aria-hidden="true"></i>子恒</a></span>&nbsp;<span class="post-publish">published on <time datetime="2018-08-14">2018-08-14</time></span>&nbsp;<span class="post-category">included in <a href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"><i class="far fa-folder fa-fw" aria-hidden="true"></i>机器学习</a></span></div><div class="content">C1W1: 什么是deep learning 单一神经元 deeplearning是模拟大脑的一种机器学习算法。以房价预测为例：
上图把房子面积作为输入X，房价作为输出Y，通过拟合得到了一个一次函数
$$
Y=aX+b
$$
这个函数的负值均视为0，即使用了ReLU函数作为神经元的激活函数做了处理。
$$
f(x) = \max(aX+b, 0)
$$
Note: ReLU函数：f(x)=\max(0, x)，近年来使用ReLU函数代替sigmoid函数为计算速度做了巨大的提升。
看看更多特征的情况：
飞速发展 上图中可以看到传统算法和神经网络的效果的一个对比，在数据多的情况下神经网络有明显的优势。近年来以下的一些原因导致deep learning飞速发展成为主流
计算速度飞速提升，使得训练较大的神经网络成为可能 数据变多（labeled data 变多） 生命周期 一个典型的深度学习的流程，即是一个Idea-Code-Train 的循环
C1W2: 基本的神经网络 问题描述 这里从一个简单的问题开始说起：识别一个64x64的图像是否为猫：
每个像素有RGB三个值组成，64*64个像素就是12228个值。所以X可以表示为一个12228维的向量。Y则是0或1（是或不是猫咪）。
这里需要很多(X, Y)组成的labeled data数据用来学习。每个样本用如下的数学方式表示：
$$
X\in R^{n_x}, Y\in{0,1} \qquad 其中n_x为每个图片的维度(12288)
$$
训练集可以用很多样本表示：
$$
\textrm{m training examples: } \{(X^{(1)}, Y^{(1)}), (X^{(2)}, Y^{(2)}), &hellip; ,(X^{(3)}, Y^{(3)})\}
$$
其中每个X都有n_x列，所以整个样本集可以表示为
$$
X\in R^{n_x\times m},Y \in R^{1 \times m}
$$
逻辑回归 Sigmoid函数 在开始正题之前，先看一个函数：</div><div class="post-footer">
        <a href="/c1w1-c1w2/">Read More</a><div class="post-tags">
                <i class="fas fa-tags fa-fw" aria-hidden="true"></i>&nbsp;<a href="/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/">深度学习</a>,&nbsp;<a href="/tags/deeplearning.ai/">deeplearning.ai</a></div></div>
</article><article class="single summary" itemscope itemtype="http://schema.org/Article"><h1 class="single-title" itemprop="name headline">
        <a href="/gdb/">[Linux]GDB调试技巧</a>
    </h1><div class="post-meta"><span class="post-author"><a href="about" title="Author" rel="author" class="author"><i class="fas fa-user-circle fa-fw" aria-hidden="true"></i>子恒</a></span>&nbsp;<span class="post-publish">published on <time datetime="2017-12-17">2017-12-17</time></span>&nbsp;<span class="post-category">included in <a href="/categories/c++/"><i class="far fa-folder fa-fw" aria-hidden="true"></i>C++</a></span></div><div class="content">命令行参数 gdb有下面几种运行方式：
1 2 3 4 5 6 // 1. 通过coredump文件，或者存在的进程id分析，不会拉起新进程 gdb [options] [executable-file [core-file or process-id]] // 2. 带参数运行程序 gdb [options] --args executable-file [inferior-arguments ...] // 3. redhat等含有用于调试python的工具 // gdb [options] [--python|-P] script-file [script-arguments ...] 几个值得注意的参数：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 和上面的类似，使用参数指定的 --args Arguments after executable-file are passed to inferior --core=COREFILE Analyze the core dump COREFILE. --pid=PID Attach to running process PID.</div><div class="post-footer">
        <a href="/gdb/">Read More</a><div class="post-tags">
                <i class="fas fa-tags fa-fw" aria-hidden="true"></i>&nbsp;<a href="/tags/gdb/">GDB</a>,&nbsp;<a href="/tags/c&#43;&#43;/">c&#43;&#43;</a></div></div>
</article><article class="single summary" itemscope itemtype="http://schema.org/Article"><h1 class="single-title" itemprop="name headline">
        <a href="/nosql_base/">[后台]分布式基础概念</a>
    </h1><div class="post-meta"><span class="post-author"><a href="about" title="Author" rel="author" class="author"><i class="fas fa-user-circle fa-fw" aria-hidden="true"></i>子恒</a></span>&nbsp;<span class="post-publish">published on <time datetime="2017-11-09">2017-11-09</time></span>&nbsp;<span class="post-category">included in <a href="/categories/%E5%90%8E%E5%8F%B0/"><i class="far fa-folder fa-fw" aria-hidden="true"></i>后台</a></span></div><div class="content">CAP Brewer&rsquo;s CAP Theorem, 2009
CAP理论是分布式系统的基石，他指出了分布式系统的以下特性：
Consistency 强一致性(返回的数据时刻一致) Availability 高可用性(服务一直可用，响应时间正常) Tolerance of network Partition 分区容错性(保证有机器宕机服务依然正常) CAP理论表明，一个分布式系统不可能同时满足一致性，可用性和分区容错性这三个需求，
最多只能同时满足两个。证明可以看上面的链接。
所以架构师往往要做出牺牲某一特性的选择：
CP：金融行业的数据库，价格昂贵，符合ACID
CA：传统关系型数据库，用于小型系统或单机系统
AP：key-value数据库，现代UGC服务基本都是这种架构，用最终一致性来换取高可用和分区容错性。
电商：牺牲少量的可用性和一致性，比较平衡，符合BASE
ACID 老生常谈的数据库事务的特性：
原子性(Atomicity) 事务中有失败，立即回滚到执行前。没有失败，全部成功
一致性(Consistency) 事务执行后数据的约束没有被破坏
隔离性(Isolation） 事务之间不交叉进行
持久性(Durability） 事务完成，永久储存
BASE 可伸缩性最佳实践：来自eBay的经验
BASE理论是对CAP理论的延伸，核心思想是即使无法做到强一致性（CAP的Consistency），但应用可以采用适合的方式达到最终一致性，来保证系统的容量和可用性。
Basically Availble （基本可用） 基本可用是指系统只保证核心可用，在访问量突增时采用有损服务的策略，让部分用户使用降级的服务。
什么是基本可用的服务？以秒杀为例：
逻辑有损：秒杀时只执行重要逻辑，加载资源可以先使用预加载的或者小图等
业务有损：秒杀需要会员、抢秒杀资格
流程有损：比如秒杀时前段丢掉大部分请求，从后端少量请求中选取中奖的请求处理
Soft-state （软状态/柔性事务） &ldquo;Soft state&rdquo; 可以理解为&quot;无连接&quot;的, 而 &ldquo;Hard state&rdquo; 是&quot;面向连接&quot;的。换句话说，软状态的数据库可能存在很多中间状态，不同节点到达最终统一的状态前会有延迟（如异步复制）。
Eventual Consistency （最终一致性） 并非时刻保持一致，所有复制节点在某段时间后保持一致。
最终一致性是弱一致性的一种特例：
Step 1. A首先write了一个值到存储系统
Step 2. 存储系统保证在A,B,C后续读取之前没有其它写操作更新同样的值
Step 3. 最终所有的读取操作都会读取到最A写入的最新值
从A写入到读取操作读取成功有一定的时间，即不一致性窗口。如果没有失败发生的话，“不一致性窗口”的大小依赖于以下的几个因素：交互延迟，系统的负载，以及备机slave的个数。最终一致性方面最出名的系统可以说是DNS系统，当更新一个域名的IP以后，根据配置策略以及缓存控制策略的不同，最终所有的客户都会看到最新的值。
在下一篇文章的中，会表明只要集群$V_r + V_w \leq N$，即此时读取和写入操作是不重叠的， 就能保证最终一致性。这个时候不一致性的窗口依赖于存储系统的异步实现方式，不一致性的窗口大小就等于从更新开始到所有的节点都异步更新完成之间的时间。</div><div class="post-footer">
        <a href="/nosql_base/">Read More</a><div class="post-tags">
                <i class="fas fa-tags fa-fw" aria-hidden="true"></i>&nbsp;<a href="/tags/nosql/">NOSQL</a>,&nbsp;<a href="/tags/cap/">CAP</a>,&nbsp;<a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a></div></div>
</article><article class="single summary" itemscope itemtype="http://schema.org/Article"><h1 class="single-title" itemprop="name headline">
        <a href="/size_of_things/">[C++]sizeof那些事儿</a>
    </h1><div class="post-meta"><span class="post-author"><a href="about" title="Author" rel="author" class="author"><i class="fas fa-user-circle fa-fw" aria-hidden="true"></i>子恒</a></span>&nbsp;<span class="post-publish">published on <time datetime="2017-08-16">2017-08-16</time></span>&nbsp;<span class="post-category">included in <a href="/categories/c++/"><i class="far fa-folder fa-fw" aria-hidden="true"></i>C++</a></span></div><div class="content">sizeof 是什么 首先明确一点，sizeof是运算符，不是函数。运算符是一个对于编译器来说的概念，是由编译器处理的，在程序编译好之后所有的sizeof都已经被替换为实际的值。类似的还有decltype。所以像
1 sizeof(++i); 这类的语句是不会改变i的值的。在C99之后，sizeof增加了一些运行时特性，可以算出可变数组的大小，像这样：
1 2 3 4 int num; scanf(&#34;%d&#34;, &amp;num);	//input 4 int arr[num]; sizeof(arr);	//output 16 sizeof 怎么用 sizeof 支持下面的语法：
1 2 sizeof(type) (1) 以字节数返回type类型对象表示的大小 sizeof expression (2) 以字节数返回expression的类型对象表示的大小 其中，sizeof(char)、 sizeof(signed char)以及sizeof(unsigned char)始终返回1。
sizeof不能用于函数类型、不完整类型（含void）或位域左值。在一些编译器里，sizeof(void)会返回0，但这是没有定义的。
普通的sizeof 几个上面用法的例子：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 int main(void) { // type argument: printf(&#34;sizeof(float) = %u\n&#34;, sizeof(float)); //4 printf(&#34;sizeof(void(*)(void)) = %u\n&#34;, sizeof(void(*)(void))); //4 printf(&#34;sizeof(char[10]) = %u\n&#34;, sizeof(char[10])); //10 // expression argument: printf(&#34;sizeof &#39;a&#39; = %u\n&#34;, sizeof &#39;a&#39;); // &#39;a&#39;的类型是int, 4 // printf(&#34;sizeof main = %zu\n&#34;, sizeof main); // 错误：函数类型 printf(&#34;sizeof &amp;main = %u\n&#34;, sizeof main()); //类型为返回值int, 4 printf(&#34;sizeof \&#34;hello\&#34; = %u\n&#34;, sizeof &#34;hello&#34;); // 类型为char[6], 6 printf(&#34;sizeof(\&#34;12345\&#34; + 1) = %u\n&#34;, sizeof(&#34;12345&#34; + 1)); // 类型为指针, 4 } 需要注意的是，在函数传参等数组退化为指针的时候sizeof返回的当然是指针大小，切忌用它来计算数组大小。</div><div class="post-footer">
        <a href="/size_of_things/">Read More</a><div class="post-tags">
                <i class="fas fa-tags fa-fw" aria-hidden="true"></i>&nbsp;<a href="/tags/c&#43;&#43;/">c&#43;&#43;</a>,&nbsp;<a href="/tags/sizeof/">sizeof</a></div></div>
</article><article class="single summary" itemscope itemtype="http://schema.org/Article"><h1 class="single-title" itemprop="name headline">
        <a href="/cpp_threadpool/">[C++]C++ 100行实现线程池</a>
    </h1><div class="post-meta"><span class="post-author"><a href="about" title="Author" rel="author" class="author"><i class="fas fa-user-circle fa-fw" aria-hidden="true"></i>子恒</a></span>&nbsp;<span class="post-publish">published on <time datetime="2017-04-07">2017-04-07</time></span>&nbsp;<span class="post-category">included in <a href="/categories/c++/"><i class="far fa-folder fa-fw" aria-hidden="true"></i>C++</a></span></div><div class="content">一个100行左右的简单线程池。用到了std::mutex和std::thread等新特性。
线程池模型 首先把每个函数抽象为一个任务(Task)，任务的过程就是调用这个Task的run函数。
然后把线程池中的线程封装为一个线程类（Thread），一直等待调度器分配任务（空闲状态），如果有任务分配立即进入忙状态。等任务执行结束再次变为空闲状态。
最后是一个调度器类（TreadPool），包含任务队列（随时添加新任务），和一个包含了Thread的vector（线程池中的线程）。如果任务队列非空，调度器每次从中取出一个任务，然后轮询线程池，搜寻空闲线程并把这个任务交给线程。
模型如下图所示：
代码实现 下面的代码实现了上述模型。其中Task类通过睡眠一定的秒数模拟任务，可以看到T1先执行完毕（1秒完毕），T2和T3在之后同时完毕，说明调度非常成功。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 //linux, g++ -std=c++14 -o t *.</div><div class="post-footer">
        <a href="/cpp_threadpool/">Read More</a><div class="post-tags">
                <i class="fas fa-tags fa-fw" aria-hidden="true"></i>&nbsp;<a href="/tags/c&#43;&#43;/">c&#43;&#43;</a>,&nbsp;<a href="/tags/c&#43;&#43;11/"> c&#43;&#43;11</a></div></div>
</article><article class="single summary" itemscope itemtype="http://schema.org/Article"><h1 class="single-title" itemprop="name headline">
        <a href="/cpp_multithreading/">[C++]C++多线程基础</a>
    </h1><div class="post-meta"><span class="post-author"><a href="about" title="Author" rel="author" class="author"><i class="fas fa-user-circle fa-fw" aria-hidden="true"></i>子恒</a></span>&nbsp;<span class="post-publish">published on <time datetime="2017-04-03">2017-04-03</time></span>&nbsp;<span class="post-category">included in <a href="/categories/c++/"><i class="far fa-folder fa-fw" aria-hidden="true"></i>C++</a></span></div><div class="content">各种锁的基本概念以及在C++里的使用，还有C的一个生产消费模型。
操作系统的知识 概念 临界区：访问和操作共享数据的代码段
避免死锁：嵌套加锁时按顺序加锁, 防止发生饥饿
原子操作：atomic_t
自旋锁 自旋锁：请求该锁的线程在等待时自旋（特别耗费处理器时间），所以只能轻量级加锁（一般锁的时间小于上下文切换的开销）。
注意：对数据而不是对代码加锁。
读写自旋锁：读时(允许读，不允许写)，写时（不允许读，不允许写）。
注意：不能把读锁升级为写锁，不然会死锁。读写操作要清晰地分开。
信号量 信号量：请求锁的进程在等待时加入等待队列并睡眠。一般用于长时间加锁（唤醒、睡眠、加入队列都是很大的开销）。
通过P/V或者down()/up()操作来控制允许同时进行的线程数。信号量减一就等同与获取一个锁，锁为负数时线程就会进入等待队列。
0/1信号量（互斥信号量）：只允许同时一个线程执行。
计数信号量：允许同时多个线程执行。
读写信号量：互斥信号量的一种。
互斥体 互斥体(mutex): 可以睡眠的强制互斥锁。比信号量更加首选。
mutex和自旋锁的区别：
需求 加锁方法 低开销加锁 优先自旋锁 短期加锁 优先自旋锁 长期加锁 优先mutex 中断上下文加锁 只能自旋锁 持有锁时需要睡眠 只能mutex C++11 的线程库 std::thread std::thread用于创建一个执行的线程实例，所以它是一切并发编程的基础，使用时需要包含头文件，它提供了很多基本的线程操作，例如get_id()来获取所创建线程的线程 ID，例如使用join()来加入一个线程等。
std::mutex, std::unique_lock, std::lock_guard 使用std::mutex创建互斥体，std::unique_lock上锁。由于C++保证了所有栈对象在声明周期结束时会被销毁，所以这样的代码是异常安全的。无论发生异常还是正常结束，都会自动调用unlock()。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include &lt;iostream&gt; #include &lt;thread&gt; #include &lt;mutex&gt; std::mutex mtx; void block_area() { std::unique_lock&lt;std::mutex&gt; lock(mtx); //.</div><div class="post-footer">
        <a href="/cpp_multithreading/">Read More</a><div class="post-tags">
                <i class="fas fa-tags fa-fw" aria-hidden="true"></i>&nbsp;<a href="/tags/c&#43;&#43;/">c&#43;&#43;</a>,&nbsp;<a href="/tags/c&#43;&#43;11/"> c&#43;&#43;11</a>,&nbsp;<a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"> 操作系统</a></div></div>
</article><article class="single summary" itemscope itemtype="http://schema.org/Article"><h1 class="single-title" itemprop="name headline">
        <a href="/cpp11_3/">[C++]C++ 11/14 笔记（三）</a>
    </h1><div class="post-meta"><span class="post-author"><a href="about" title="Author" rel="author" class="author"><i class="fas fa-user-circle fa-fw" aria-hidden="true"></i>子恒</a></span>&nbsp;<span class="post-publish">published on <time datetime="2017-01-30">2017-01-30</time></span>&nbsp;<span class="post-category">included in <a href="/categories/c++/"><i class="far fa-folder fa-fw" aria-hidden="true"></i>C++</a></span></div><div class="content">本部分介绍了c++11的容器、智能指针和正则。
std::array 代替原来的c数组，提供了size()，empty()，大小比较以及迭代器。
注意：
声明的第二个模板参数必须是编译期常量 不能隐式转换为指针，调用data()返回c数组地址 1 2 3 4 5 6 7 8 9 std::array&lt;int,4&gt; arr = {1,2,3,4}; // C 风格接口传参 // foo(arr, arr.size()); // 非法, 无法隐式转换 foo(&amp;arr[0], arr.size()); foo(arr.data(), arr.size()); // 使用 `std::sort` std::sort(arr.begin(), arr.end()); std::forward_list 单向实现的列表，提供了O(1)的插入，并且比双向更省空间。
无序容器 传统 C++ 中的有序容器 std::map/std::set，这些元素内部通过红黑树进行实现，插入和搜索的平均复杂度均为 O(log(size))。在插入元素时候，会根据 &lt; 操作符比较元素大小并判断元素是否相同，并选择合适的位置插入到容器中。当对这个容器中的元素进行遍历时，输出结果会按照 &lt; 操作符的顺序来逐个遍历。
而无序容器中的元素是不进行排序的，内部通过 Hash 表实现，插入和搜索元素的平均复杂度为 O(constant)，在不关心容器内部元素顺序时，能够获得显著的性能提升。
C++11 引入了两组无序容器：std::unordered_map, std::unordered_multimap 和std::unordered_set, std::unordered_multiset。
它们的用法和原有的std::map/std::multimap/std::set/set::multiset基本类似。
std::tuple 提供了N元组的数据结构。
该数据结构在cpp14中还不够完善。
智能指针 在传统 C++ 里我们使用 new 和 delete 去『记得』对资源进行释放。而 C++11引入了智能指针的概念，使用了引用计数的想法，让程序员不再需要关心手动释放内存。这些智能指针包括 std::shared_ptr/std::unique_ptr/std::weak_ptr，使用它们需要包含头文件 &lt;memory&gt;。</div><div class="post-footer">
        <a href="/cpp11_3/">Read More</a><div class="post-tags">
                <i class="fas fa-tags fa-fw" aria-hidden="true"></i>&nbsp;<a href="/tags/c&#43;&#43;/">c&#43;&#43;</a>,&nbsp;<a href="/tags/c&#43;&#43;11/"> c&#43;&#43;11</a></div></div>
</article><article class="single summary" itemscope itemtype="http://schema.org/Article"><h1 class="single-title" itemprop="name headline">
        <a href="/cpp11_2/">[C++]C++ 11/14 笔记（二）</a>
    </h1><div class="post-meta"><span class="post-author"><a href="about" title="Author" rel="author" class="author"><i class="fas fa-user-circle fa-fw" aria-hidden="true"></i>子恒</a></span>&nbsp;<span class="post-publish">published on <time datetime="2017-01-29">2017-01-29</time></span>&nbsp;<span class="post-category">included in <a href="/categories/c++/"><i class="far fa-folder fa-fw" aria-hidden="true"></i>C++</a></span></div><div class="content">本部分介绍了c++11的Lambda、函数容器和右值引用。
Lambda 结构：
1 2 3 [捕获列表](参数列表) -&gt; 返回类型{ // 函数体 } 比如定义一个加法的lambda：
1 2 3 4 auto add = [](auto x, auto y) { return x+y; }; add(1.0, 2.3); 捕获列表用于传递外部的变量，分为以下几种：
[] 空捕获列表 [name1, name2, &hellip;] 捕获一系列变量 [=] 值捕获, 捕获的变量为lambda表达式被创建时的值 [&amp;] 引用捕获, 值会发生变化 函数容器 std::function 函数的类型安全的容器。比如下面的std::function&lt;int(int)&gt; func2定义了一个返回值int,参数为(int)的一个函数对象。其中捕获列表是传引用的，所以返回的是调用func2时的1+value+important的值。
1 2 3 4 int important = 10; std::function&lt;int(int)&gt; func2 = [&amp;](int value) -&gt; int { return 1+value+important; }; std::bind/std::placeholder 有点像python的偏函数，它给函数一些预定的参数，以便于用更少的参数调用：
1 2 3 4 5 6 7 8 9 int foo(int a, int b, int c) { return a + b + c; } int main() { // 将参数1,2绑定到函数 foo 上，但是使用 std::placeholders::_1 来对第一个参数进行占位 auto bindFoo = std::bind(foo, std::placeholders::_1, 1,2); // 这时调用 bindFoo 时，只需要提供第一个参数即可 bindFoo(1); } 右值引用 右值和左值 以赋值符号为界，左面的表示一个对象，右面的表示一个对象的值</div><div class="post-footer">
        <a href="/cpp11_2/">Read More</a><div class="post-tags">
                <i class="fas fa-tags fa-fw" aria-hidden="true"></i>&nbsp;<a href="/tags/c&#43;&#43;/">c&#43;&#43;</a>,&nbsp;<a href="/tags/c&#43;&#43;11/"> c&#43;&#43;11</a></div></div>
</article><article class="single summary" itemscope itemtype="http://schema.org/Article"><h1 class="single-title" itemprop="name headline">
        <a href="/cpp11_1/">[C++]C++ 11/14 笔记（一）</a>
    </h1><div class="post-meta"><span class="post-author"><a href="about" title="Author" rel="author" class="author"><i class="fas fa-user-circle fa-fw" aria-hidden="true"></i>子恒</a></span>&nbsp;<span class="post-publish">published on <time datetime="2017-01-20">2017-01-20</time></span>&nbsp;<span class="post-category">included in <a href="/categories/c++/"><i class="far fa-folder fa-fw" aria-hidden="true"></i>C++</a></span></div><div class="content">本部分介绍了c++11的崭新的类型推导、循环、模板和构造方法。
弃用的特性 1.　不允许以下赋值出现，应使用const char *后者auto。
1 char *str = &#34;hello world!&#34;; 2.　C语言风格的类型转换被弃用，应该使用 static_cast、reinterpret_cast、const_cast 来进行类型转换
3.　register， auto_ptr关键字被弃用。
语言增强 新的关键字 使用nullptr而不是NULL。新的nullptr为nullptr_t类型，可以隐式转换为任何类型，同时避免了NULL == 0这种类型冲突。
constexpr函数：告诉编译器返回的值为常量表达式
类型推导 auto类型 auto型可以作为变量的声明类型，函数的返回类型 auto型作为函数参数在c++17中才可使用，但要注意重载的问题 auto不能用于数组的类型推导
迭代器的样例： 1 for(auto itr = vec.cbegin(); itr != vec.cend(); ++itr); decltype函数 返回值为一个类型。比如我们可以把z声明为推测的类型
1 decltype(x+y) z = x + y; for(item:array)循环 像Python一样地迭代：
1 2 3 4 5 std::vector&lt;int&gt; arr(5, 100); // &amp; 启用了引用, 如果没有则对 arr 中的元素只能读取不能修改 for(auto &amp;i : arr) { std::cout &lt;&lt; i &lt;&lt; std::endl; } 初始化列表 除了</div><div class="post-footer">
        <a href="/cpp11_1/">Read More</a><div class="post-tags">
                <i class="fas fa-tags fa-fw" aria-hidden="true"></i>&nbsp;<a href="/tags/c&#43;&#43;/">c&#43;&#43;</a>,&nbsp;<a href="/tags/c&#43;&#43;11/"> c&#43;&#43;11</a></div></div>
</article><article class="single summary" itemscope itemtype="http://schema.org/Article"><h1 class="single-title" itemprop="name headline">
        <a href="/socket_in_10_lines/">[Python]Python版socket十行模板</a>
    </h1><div class="post-meta"><span class="post-author"><a href="about" title="Author" rel="author" class="author"><i class="fas fa-user-circle fa-fw" aria-hidden="true"></i>子恒</a></span>&nbsp;<span class="post-publish">published on <time datetime="2017-01-20">2017-01-20</time></span>&nbsp;<span class="post-category">included in <a href="/categories/python/"><i class="far fa-folder fa-fw" aria-hidden="true"></i>Python</a></span></div><div class="content">以下的socket
都是python实现的服务端接受客户端键盘输入的信息，改为大写返回客户端的模板
都是同步、阻塞的
都会在数据长度大于1024时产生错误，请自己写协议
端口都是8080，请确保未被占用
tcp_server.py 6行控制监听的最大tcp链接数。
tcp是有链接的。9行建立链接，10行接受数据，11行发送数据，12行关闭链接。
1 2 3 4 5 6 7 8 9 10 11 12 import socket server = socket.socket(socket.AF_INET, socket.SOCK_STREAM) server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) server.bind((&#34;0.0.0.0&#34;, 8080)) server.listen(1) while True: conn, addr = server.accept() data_from_client = conn.recv(1024).decode(&#39;utf8&#39;) conn.sendall(data_from_client.upper().encode(&#39;utf8&#39;)) conn.close() tcp_client.py 5行链接，6行发送数据，7行接收数据，9行关闭链接。
1 2 3 4 5 6 7 8 9 import socket while True: client = socket.socket(socket.AF_INET, socket.SOCK_STREAM) client.connect((&#34;0.0.0.0&#34;, 8080)) client.sendall(input().encode(&#39;utf8&#39;)) data_from_server = client.recv(1024).decode(&#39;utf8&#39;) print(&#39;GET &#39; + data_from_server) client.</div><div class="post-footer">
        <a href="/socket_in_10_lines/">Read More</a><div class="post-tags">
                <i class="fas fa-tags fa-fw" aria-hidden="true"></i>&nbsp;<a href="/tags/python/"> Python</a>,&nbsp;<a href="/tags/socket/">socket</a></div></div>
</article><ul class="pagination"><li class="page-item ">
                    <span class="page-link">
                        <a href="/">1</a>
                    </span>
                </li><li class="page-item ">
                    <span class="page-link">
                        <a href="/page/2/">2</a>
                    </span>
                </li><li class="page-item active">
                    <span class="page-link">
                        <a href="/page/3/">3</a>
                    </span>
                </li><li class="page-item ">
                    <span class="page-link">
                        <a href="/page/4/">4</a>
                    </span>
                </li><li class="page-item ">
                    <span class="page-link">
                        <a href="/page/5/">5</a>
                    </span>
                </li></ul></div></div>
            </main><footer class="footer">
        <div class="footer-container"><div class="footer-line">Powered by <a href="https://gohugo.io/" target="_blank" rel="noopener noreffer" title="Hugo 0.118.2">Hugo</a> | Theme - <a href="https://github.com/dillonzq/LoveIt" target="_blank" rel="noopener noreffer" title="LoveIt 0.2.11"><i class="far fa-kiss-wink-heart fa-fw" aria-hidden="true"></i> LoveIt</a>
                </div><div class="footer-line" itemscope itemtype="http://schema.org/CreativeWork"><i class="far fa-copyright fa-fw" aria-hidden="true"></i><span itemprop="copyrightYear">2015 - 2023</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="about" target="_blank">子恒</a></span>&nbsp;|&nbsp;<span class="license"><a rel="license external nofollow noopener noreffer" href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a></span></div>
        </div>
    </footer></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="Back to Top">
                <i class="fas fa-arrow-up fa-fw" aria-hidden="true"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="View Comments">
                <i class="fas fa-comment fa-fw" aria-hidden="true"></i>
            </a>
        </div><link rel="stylesheet" href="/lib/lightgallery/css/lightgallery-bundle.min.css"><link rel="stylesheet" href="/lib/katex/katex.min.css"><script type="text/javascript" src="/lib/autocomplete/autocomplete.min.js"></script><script type="text/javascript" src="/lib/lunr/lunr.min.js"></script><script type="text/javascript" src="/lib/lazysizes/lazysizes.min.js"></script><script type="text/javascript" src="/lib/lightgallery/lightgallery.min.js"></script><script type="text/javascript" src="/lib/lightgallery/plugins/thumbnail/lg-thumbnail.min.js"></script><script type="text/javascript" src="/lib/lightgallery/plugins/zoom/lg-zoom.min.js"></script><script type="text/javascript" src="/lib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="/lib/sharer/sharer.min.js"></script><script type="text/javascript" src="/lib/typeit/index.umd.js"></script><script type="text/javascript" src="/lib/katex/katex.min.js"></script><script type="text/javascript" src="/lib/katex/contrib/auto-render.min.js"></script><script type="text/javascript" src="/lib/katex/contrib/copy-tex.min.js"></script><script type="text/javascript" src="/lib/katex/contrib/mhchem.min.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"Copy to clipboard","maxShownLines":50},"data":{"id-1":"上郡周生，家贫。自幼刻苦自励，十八岁中进士，官县尉，然朝中多子弟，五年不得右迁。一日郁郁步于山中树下，欲引颈自缢，然不慎倾跌，滚入一洞中，只见水雾弥漫，宛若仙境。忽闻两少年，姿容甚美，言化人形之事。”我以数百年化形，何如？”“必有成于世人之前，故晨夕不休，十年化形。然化形为妖之终，人之终，何也？”“终是死，惟一抔土耳”。闻言，少年自断其颈，化作灰土。顿山摇地晃，洞欲塌。周生大惊，奔逃出山。即辞官远游，遁匿无迹。"},"lightgallery":true,"math":{"delimiters":[{"display":true,"left":"$$","right":"$$"},{"display":true,"left":"\\[","right":"\\]"},{"display":true,"left":"\\begin{equation}","right":"\\end{equation}"},{"display":true,"left":"\\begin{equation*}","right":"\\end{equation*}"},{"display":true,"left":"\\begin{align}","right":"\\end{align}"},{"display":true,"left":"\\begin{align*}","right":"\\end{align*}"},{"display":true,"left":"\\begin{alignat}","right":"\\end{alignat}"},{"display":true,"left":"\\begin{alignat*}","right":"\\end{alignat*}"},{"display":true,"left":"\\begin{gather}","right":"\\end{gather}"},{"display":true,"left":"\\begin{CD}","right":"\\end{CD}"},{"display":false,"left":"$","right":"$"},{"display":false,"left":"\\(","right":"\\)"}],"strict":false},"search":{"highlightTag":"em","lunrIndexURL":"/index.json","maxResultLength":10,"noResultsFound":"No results found","snippetLength":50,"type":"lunr"},"typeit":{"cursorChar":"|","cursorSpeed":1000,"data":{"id-1":["id-1"]},"duration":-1,"speed":200}};</script><script type="text/javascript" src="/js/theme.min.js"></script></body>
</html>
