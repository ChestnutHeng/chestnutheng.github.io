---
title: "[mysql]索引"
date: 2023-04-23T14:45:11+08:00
lastmod: 2023-04-23T14:45:11+08:00
draft: true
description: "Mysql中，设计一个表的DDL有哪些经验和注意点？"
tags: ["数据库", "mysql"]
categories: ["数据库"]
---

# 数据类型设计

数据库的字段一旦定好，后期就很难改变。我们随便定一个实体表，看看里面有哪些需要注意的细节。
```
CREATE TABLE `t_entity_table` (
  `id` bigint unsigned NOT NULL AUTO_INCREMENT COMMENT '主键id，自增',
  `entity_id` bigint NOT NULL DEFAULT '0' COMMENT '实体id',
  `entity_name` varchar(255) NOT NULL DEFAULT '' COMMENT '实体名称',
  `out_id` bigint NOT NULL DEFAULT '0' COMMENT '关联id',
  `status` int NOT NULL DEFAULT '1' COMMENT '状态 1-xxx 2-xxx',
  `url` varchar(255) DEFAULT NULL COMMENT '链接',
  `version` bigint NOT NULL DEFAULT '0' COMMENT '版本号',
  `create_idempotent` varchar(255) NOT NULL DEFAULT '' COMMENT '创建幂等键',
  `deleted_time` bigint NOT NULL DEFAULT '0' COMMENT '软删除时间',
  `create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
  `extra` mediumtext COMMENT '扩展字段',
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_entity_id` (`entity_id`,`deleted_time`),
  KEY `idx_out_id` (`out_id`),
  KEY `idx_entity_name` (`entity_name`)
) ENGINE=InnoDB AUTO_INCREMENT=180 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci COMMENT='某实体表'
```


2. **尽量避免NULL**：我们在每个字段后都加上NOT NULL和DEFAULT。这对索引、值判断减少了很多坑。我在做业务的时候没见过需要必须是NULL的。
3. **整型**：更大的INT通常更好（做业务）。小的数据类型并不能带来明显的业务感知的性能提升（比如对比tinyint和bigint），但是却有很多溢出导致事故的案例。所以，我们建议在合理的情况下，尽可能选择大的数据类型，除非你的字段一定不会扩展（比如某些bool类型。但是与此同时建议使用tinyint，而不是bool）
5. **小数**：我们在存储账户金额等高精度的数据时，应该尽量采用BIGINT，将单位改为分或者单位改为1e-6元（考虑国际化）。decimal(位数,小数位数)也可以用于小数存储，性能稍差
6. **存储json**：(B端)json类型用text，而不是varchar或者json。我们的json数据保证不作为where或者order的条件出现的时候，text更有灵活性，且相比varchar(255+)性能几乎相当。所以，文本都用text，而字符串，比如名称、主题等用varchar。另外，在默认宽松模式下，varchar更容易产生截断的数据写入的情况。
7. **宽度**：int(11)后面的数字是没有意义的，只影响客户端交互的宽度，并不影响查询和检索
8. **字符集**：就用`utf8mb4_general_ci`吧，兼容性最好，还支持emoji，避免之后遇到奇奇怪怪的错误
9. **ID**：id不要使用自增主键，而是用全局id生成器生成
11. **删除**：不要使用硬删除。`delete_at`字段是一般情况下建议的软删除方式。可以配合orm的钩子使用。
12. **时间戳**：时间戳尽量选用bigint。timestamp是32位的，相比较之下，bigint可以提供超过2038年的范围、毫秒级时间戳的兼容能力，以及更快的检索速度。且在严格模式下零值也更好控制。

# 索引设计

1. 索引不宜太多，尽量在5个以下
2. 综合所有查询场景设计索引，并保障复用性。可以尽量设计成联合索引，并把区分度高的放在左边
3. 区分度过低不要建索引。`count(distinct 列) / count(*) < 0.2`和全表扫描几乎性能一样。
4. 业务语义上的唯一索引必须建成uk。约束在最底层生效往往更安全，而不是先查询后插入
5. varchar建立索引指定长度。很多为了避免阶段设计成诸如varchar(1023)的格式，建立索引一定要指定长度
6. 可以设计覆盖索引提高关键信息检索的性能，避免回表。
7. 不要join语句，而是在业务中自己join或者采用es
8. order by字段建立索引，避免file sort

# 功能设计

1. 不要使用子查询，不要使用反向筛选（not in，not like）
2. 操作记录不要超过N000条，比如insert，update，in，拆分成多批小批量操作


