---
title: '[后台]服务端高性能架构之道（缓存篇）'
date: 2022-01-04T17:23:09+08:00
lastmod: 2022-01-04T17:23:14+08:00
tags: ["后台"]
categories: ["后台"]
draft: true
description: 缓存是后台小伙伴必备的技能，涉及到高性能，低延时、QPS很高的接口，必须要有缓存；缓存也是很多性能优化case的法宝，但同时也是数据不一致、数据没更新的罪魁祸首。但是设计的时候，大家有没有详细思考过缓存该怎么设计？每种设计方法会带来什么问题？
---

#  缓存设计

# 前言

缓存是后台小伙伴必备的技能，涉及到高性能，低延时、QPS很高的接口，必须要有缓存；缓存也是很多性能优化case的法宝，但同时也是数据不一致、数据没更新的罪魁祸首。但是设计的时候，大家有没有详细思考过缓存该怎么设计？每种设计方法会带来什么问题？


## 什么时候用缓存
后台服务中使用的缓存，其实思路也是来源于CPU的缓存（我们大学时学过的寄存器-L1-主存-磁盘的分层架构）。
[参考资料：cos316 缓存](https://www.cs.princeton.edu/courses/archive/fall19/cos316/lectures/08-caching.pdf)
我们先看看几种常见的业务场景中缓存的价值：

![什么时候用缓存](https://chestnutheng-blog-1254282572.cos.ap-chengdu.myqcloud.com/2021/cache1.jpg)
情况A：重复查询，绝大多数的请求在查少数item；比如微博、抖音、社区的图文视频，淘宝的商品信息
情况B：随机查询，每个item被查询次数几乎相等；比如用户画像，用户的不公开的QQ相册，淘宝订单
情况C：顺序查询，item依次被查询；比如在线视频音频流，在线会议

情况A里面，像微博热帖、抖音热榜、社区热门，这些内容，缓存的命中率非常高，缓存的item个数少，收益也很大
情况B里面，典型的就是用户数据，如果要在这上面做缓存，缓存命中率非常低（笔者曾缓存过几天的用户数据，命中率都不到10%），缓存的item个数非常多（数GB），收益就很低
情况C里面，直接做缓存命中率也是极低，一般采用预读取、分块读取的方式，不使用缓存方案
所以，我们决定要不要缓存之前一定要估计缓存的**命中率**和**量级**

## 

# 缓存模式
[缓存更新的套路](https://coolshell.cn/articles/17416.html)

## Cache Aside

Cache Aside是Facebook在论文[《Scaling Memcache at Facebook》](https://www.usenix.org/system/files/conference/nsdi13/nsdi13-final170_update.pdf)中提出来的，是大多数情况下，多读少写的缓存的最佳实践。我们一般设计缓存遵循这种套路就好了。

### 策略 How

* 读数据：
    * Hit：读到cache，直接返回
    * Miss：先读cache，如果key不存在则回源读数据库，同时更新cache。
* 写数据：
a.  先更新数据库，再等待key过期自动刷新
b.  先更新数据库，再同时更新缓存
c.  先更新数据库，再删掉cache对应的key（推荐）
![Cache Aside](https://chestnutheng-blog-1254282572.cos.ap-chengdu.myqcloud.com/2021/cache2.jpg)

示例：
```go
func GetArticle(key string) Article{
    article := redis.Get(key)
    if article == nil {
        article = db.Get(key)
        redis.Set(key, article, time.Minute*1)
    }
    return article
}

func SetArticle(key string, data Article){
    if article == nil {
        return
    }
    db.Set(key, data)
    // do nothing 方案a
    // redis.Set(key, data) // 方案b
    // redis.Del(key) // 方案c
}
```

###  问题 Why

#### 问题1：写的时候，先更新数据源还是先更新缓存？
**先更新缓存，再更新数据源**，读写并发的时候，会有这样的序列
如果写入的时候删除缓存：
1. （请求A）写操作，删除缓存
2. （请求B）查询发现缓存为空
3. （请求B）去数据库查询得到旧值，将旧值写入缓存
4. （请求A）请求A将新值写入数据库

如果写入的时候更新缓存：
1. （请求B）查询发现缓存过期
2. （请求A）进行写操作，更新缓存
3. （请求B）去数据库查询得到旧值，将旧值写入缓存
4. （请求A）请求A将新值写入数据库

两种方法的第3步骤都会导致缓存被写脏。如果采取的是删除缓存的方式且缓存没有过期时间，缓存可能会一直脏下去。
触发条件：在读/写请求进行数据库操作等待回包的时间窗口内，任何写/读请求都会把缓存写脏，概率较高
解决办法：不要用

#### 问题2：先更新数据源会有问题吗
**先更新数据源，再更新缓存**，读写并发的时候，会有以下序列（括号里的读写分别是独立操作）
1. （请求A）读缓存，发现空，回源数据库，得到老值
2. （请求B）更新数据库，写入新值
3. （请求B）更新缓存/逐出缓存/不操作
4. （请求A）更新缓存，写入老值

第4步骤会把老的脏数据覆盖进去
触发条件：读的操作比写操作速度慢的时候，概率极低
解决办法：用2PC或者一致性协议解决

#### 问题3：写的时候，不处理/写缓存/删除缓存 哪种方式好？
不处理：不一致窗口很长，且依赖key必须有过期时间，但是实现简单，性能最高
写缓存：不一致窗口最短，性能最低，一致性最高
删除缓存：不一致窗口很短，性能中，推荐使用

反思：
1. 一定要有过期时间。无论是什么方案，只要有过期时间，就不会永远数据不一致。过期时间的长短直接决定数据不一致的时间窗口。
2. 只要不用分布式一致性协议，数据总有不一致的可能。Cache Aside这种实现只是把不一致的概率降到了最低。

### 优缺点
优点：
1. 适合多读少写的场景
2. 缓存失败可以请求数据库，保留一定可用性

缺点：
1. 业务逻辑复杂（尤其三层及以上缓存时），且复杂度都在应用层
2. 击穿db的时候延时较高
3. 击穿db有风险，可能导致db压力过大

## Write Behind Cache

解决问题：数据一致性，数据竞争，平滑切换

### 锁的粒度

全表

单key

分段

dirty map

### 切换

 单内存

 双倍内存

### 实现

### 优缺点

可以全量缓存数据，当做灾备

## Read/Write Through Pattern

# 缓存的问题


## 不一致性

## 缓存热点

## 