---
title: "[架构]DDD"
date: 2023-04-23T14:45:11+08:00
lastmod: 2023-04-23T14:45:11+08:00
draft: true
description: "什么是DDD，为什么需要DDD？怎么使用DDD？"
tags: ["架构"]
categories: ["架构"]
---

# 为什么需要领域

之前在文章里讲过，所有架构都是在治理复杂度，一切好的架构都满足下面几个要求，抱着一样的目的（高内聚，低耦合）
- 可复用性：迭代成本低，改动少
- 可读性：代码清晰易于理解
- 可维护性：上手简单，易于维护

我们回顾了失血、贫血、充血模型的设计，其实很像历史上架构模式的演进
* cs架构（失血），所有的代码都围绕数据库设计编写，基本不可复用
* 三层式架构，分为接入层-逻辑层-数据层，对能力做了简单封装


# 领域的名词

[实体和值对象](https://www.cnblogs.com/Courage129/p/14855483.html)

领域：又称为问题域，往往就是业务的某一个部分，例如电商的销售部分、物流部分、供应链部分；我们用领域把问题圈在了一个边界内，着力于解决边界内的业务问题。领域可以有子域，子域也可以有子域，可以层层拆解问题到最细的粒度

子域：领域可以进一步划分为子领域，称为子域，每个子域对应一个更小的问题域。
核心域：决定产品和公司核心竞争力的子域是核心域，它是业务成功的主要因素和公司的核心竞争力。 
通用域：没有太多个性化的诉求，同时被多个子域所使用的通用功能子域。
支撑域：必需但又不包含决定产品和公司核心竞争力的功能，也不包含通用功能的子域，它就是支撑域。

实体：具有唯一标识、连续性（指的是属性可能会发生变化）
* 可能是一个人，一辆车，一次比赛
* 实体具有业务属性、业务行为和业务逻辑
* 一般用充血模型实现自己的逻辑
* 一般在数据库中对应表
```go
// Person is a entity that represents a person in all Domains
type Person struct {
	// ID is the identifier of the Entity, the ID is shared for all sub domains
	ID uuid.UUID
	Name string
	Age int
}
```

值对象：不需要唯一标识、属性不可变
* 用于封装某几个属性，比如地址（省、市、县），交易（入款方、出款方、时间）
* 一般不具有业务逻辑，只有序列化和整体替换
* 一般在数据库中作为一张表，或者实体的一个json字段存储
* 大部分场景和实体可以互换

```go
// 仅仅作为举例。一般情况下交易都需要交易ID
type Transaction struct {
	// all values lowercase since they are immutable
	amount int
	from uuid.UUID
	to uuid.UUID
	createdAt time.Time
}
```

聚合：
聚合就是由业务和逻辑紧密关联的一组实体和值对象组合而成的，是一个最小的业务边界
* 是领域的“高内聚，低耦合”的最小单元，领域层包含了多个聚合
* 是数据修改和持久化的基本单元，可以考虑每一个聚合对应一个仓储
* 跨多个实体的业务逻辑通过领域服务来实现，跨多个聚合的业务逻辑通过应用服务来实现
* 聚合之间通过关联外部聚合根ID的方式引用
* 应该避免跨聚合的领域服务调用和跨聚合的数据库表关联
* 聚合可以作为独立微服务（如对性能有极致要求的场景中，支持高频发布和弹性伸缩），但也要小心微服务的过度拆分

聚合根：
是实体的一种，拥有实体的业务属性和行为，同时也是聚合的管理者，负责协调聚合内的实体和值对象，按照固定的业务规则，完成业务逻辑。
* 聚合根是聚合对外唯一的接口人，外部访问聚合内实体需要通过聚合根id
* 作为实体本身，拥有实体的属性和业务行为，实现自身的业务逻辑
* 实体一般从属于某个聚合根，要不然就可以定义成聚合根

# 
领域建模的步骤

统一语言
统一语言可以统一业务术语，减少产品、研发、QA等不同角色的理解成本

