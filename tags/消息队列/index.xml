<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>消息队列 on 子恒的博客</title>
    <link>http://chestnutheng.github.io/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</link>
    <description>Recent content in 消息队列 on 子恒的博客</description>
    <generator>Hugo</generator>
    <language>zh-CN</language>
    <lastBuildDate>Tue, 19 Nov 2019 15:48:10 +0800</lastBuildDate>
    <atom:link href="http://chestnutheng.github.io/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>[后台]RocketMQ的架构和设计</title>
      <link>http://chestnutheng.github.io/rocketmq/</link>
      <pubDate>Wed, 04 Sep 2019 19:00:56 +0800</pubDate>
      <guid>http://chestnutheng.github.io/rocketmq/</guid>
      <description>&lt;p&gt;主要整理文献：&lt;br&gt;&#xA;&lt;a href=&#34;https://github.com/apache/rocketmq/blob/master/docs/cn/design.md&#34;&gt;RocketMQ部署架构和技术架构 - Github&lt;/a&gt;&lt;br&gt;&#xA;&lt;a href=&#34;https://github.com/apache/rocketmq/blob/master/docs/cn/design.md&#34;&gt;RocketMQ关键机制的设计原理 - Github&lt;/a&gt;&lt;br&gt;&#xA;&lt;a href=&#34;http://gd-rus-public.cn-hangzhou.oss-pub.aliyun-inc.com/attachment/201604/08/20160408165024/RocketMQ_design.pdf&#34;&gt;RocketMQ 原理简介 - 淘宝消息中间件项目组&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;设计理念和部署&#34;&gt;设计理念和部署&lt;/h1&gt;&#xA;&lt;h2 id=&#34;消息队列需要解决的问题&#34;&gt;消息队列需要解决的问题&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;strong&gt;发布/订阅&lt;/strong&gt; 最基础的需求，可以做解耦&amp;amp;聚合，如果用Redis做，不够可靠&lt;/li&gt;&#xA;&lt;li&gt;支持&lt;strong&gt;优先级队列、延时队列&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;顺序消费&lt;/strong&gt;，rockmq严格有序&lt;/li&gt;&#xA;&lt;li&gt;支持&lt;strong&gt;消息过滤&lt;/strong&gt;，Producer和consumer共同过滤&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;持久化&lt;/strong&gt; 内存缓存+文件&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;异常恢复&lt;/strong&gt;&lt;br&gt;&#xA;broker crash，os crash，掉电 &amp;mdash;保证消息不丢，或者丢失少量数据（依赖刷盘方式是同步还是异步）&lt;br&gt;&#xA;磁盘损坏，机器永久损坏  &amp;mdash;通过异步复制，可保证99%的消息不丢&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;实时性&lt;/strong&gt; RocketMQ使用长轮询Pull方式，可保证消息非常实时，消息实时性不低于Push。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;At least Once&lt;/strong&gt; 和 Exactly Only Once， 至少消费一次且只消费一次&lt;/li&gt;&#xA;&lt;li&gt;broker的&lt;strong&gt;buffer容量问题&lt;/strong&gt;。RocketMQ 的内存Buffer持久化在硬盘，抽象成一个无限长度的队列，不管有多少数据进来都能装得下，当然也会定时清理。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;回溯消费&lt;/strong&gt; 一般是按照时间维度，例如由于 Consumer 系统故障，恢复后需要重新消费 1 小时前的数据，那么 Broker 要提供一种机制，可以按照时间维度来回退消费进度。&lt;br&gt;&#xA;RocketMQ 支持按照时间回溯消费，时间维度精确到毫秒，可以向前回溯，也可以向后回溯。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;消息堆积&lt;/strong&gt; 消息堆积在内存Buffer，一旦超过内存Buffer，可以根据一定的丢弃策略来丢弃消息，对性能影响不大，但是不能堆积太多&lt;br&gt;&#xA;消息堆积到持久化存储系统中，例如DB，KV存储，文件记录形式。 当消息不能在内存Cache命中时，要不可避免的访问磁盘，会产生大量读IO，读IO的吞吐量直接决定了消息堆积后的访问能力。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;消息重试&lt;/strong&gt; 消息重试有两种原因，一种是消息本身处理失败，如编码有问题等，重试永远不会成功。另一部分是处理消息依赖的下游服务暂时不可用，一段时间重试后可以成功。所以可以消极重试，逐步重试增大等待重试间隔。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;rockmq-模块&#34;&gt;RockMQ 模块&lt;/h2&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://chestnutheng-blog-1254282572.cos.ap-chengdu.myqcloud.com/rockmq/rocketmq_architecture_1.png&#34;&gt; &lt;/img&gt;&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;Name Server&lt;/strong&gt; ：NameServer是一个非常简单的Topic路由注册中心，其角色类似Dubbo中的zookeeper，支持Broker的动态注册与发现。&lt;br&gt;&#xA;(1) 路由管理&lt;br&gt;&#xA;Broker管理：NameServer接受Broker集群的注册信息并且保存下来作为路由信息的基本数据。然后提供心跳检测机制，检查Broker是否还存活；&lt;br&gt;&#xA;路由信息管理：每个NameServer将保存关于Broker集群的整个路由信息和用于客户端查询的队列信息。然后Producer和Conumser通过NameServer就可以知道整个Broker集群的路由信息，找到对应topic的路由信息，从而进行消息的投递和消费。&lt;br&gt;&#xA;(2) 无状态：NameServer通常也是集群的方式部署，各实例间相互不进行信息通讯。它是一个几乎无状态的结点，他们之间互不通信。Broker是向每一台NameServer注册自己的路由信息，所以每一个NameServer实例上面都保存一份完整的路由信息。当某个NameServer因某种原因下线了，Broker仍然可以向其它NameServer同步其路由信息，Producer,Consumer仍然可以动态感知Broker的路由的信息。&lt;br&gt;&#xA;(3) 随机选择：客户端连接时，会随机选择。&lt;br&gt;&#xA;(4) 长连接：Broker向所有的NameServer结点建立长连接，注册Topic信息。Producer和Consumer也是长连接。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;Broker&lt;/strong&gt;：处理消息存储，转发等处理的服务器。&lt;br&gt;&#xA;(0) 分Group：Broker以group分开，每个group只允许一个master，若干个slave。&lt;br&gt;&#xA;(1) 读写分离：只有master才能进行写入操作，slave不允许。&lt;br&gt;&#xA;(2) 主从同步：slave从master中同步数据。同步策略取决于master的配置，可以采用同步双写，异步复制两种。&lt;br&gt;&#xA;(3) 默认消费：在默认情况下，消费者都从master消费，只有master挂掉或者产生消息堆积了才从slave消费。&lt;br&gt;&#xA;Broker有下面几个重要的子模块：&lt;br&gt;&#xA;(1) Remoting Module：整个Broker的实体，负责处理来自clients端的请求。&lt;br&gt;&#xA;(2) Client Manager：负责管理客户端(Producer/Consumer)和维护Consumer的Topic订阅信息&lt;br&gt;&#xA;(3) Store Service：提供方便简单的API接口处理消息存储到物理硬盘和查询功能。&lt;br&gt;&#xA;(4) HA Service：高可用服务，提供Master Broker 和 Slave Broker之间的数据同步功能。&lt;br&gt;&#xA;(5) Index Service：根据特定的Message key对投递到Broker的消息进行索引服务，以提供消息的快速查询。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
